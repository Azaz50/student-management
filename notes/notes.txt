# CRUD API Project Documentation

This document provides a detailed explanation of the CRUD API project.

## Project Overview

This project is a simple CRUD (Create, Read, Update, Delete) API built with Node.js, Express, and MongoDB. It allows managing a collection of "students", including uploading a profile picture.

The included screenshots provide conceptual background:
- `Screenshot (94).png`: Explains the general concept of an API, where client applications (web or mobile) communicate with a backend server that interacts with a database.
- `Screenshot (95).png`: Shows the basic structure of Express.js routes for handling different HTTP methods (GET, POST, PUT, DELETE), which correspond to CRUD operations.
- `Screenshot (96).png`: Illustrates the core components of `multer` for handling file uploads in Express: Storage, Limits, and File Filter.

## Project Structure

```
crud-api-project-22/
‚îú‚îÄ‚îÄ .env                  # Environment variables (like database connection string)
‚îú‚îÄ‚îÄ index.js              # Main application entry point
‚îú‚îÄ‚îÄ package.json          # Project metadata and dependencies
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ db.js             # Database connection logic
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ students.model.js # Mongoose schema and model for students
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ students.route.js # API routes for student operations
‚îÇ   ‚îî‚îÄ‚îÄ uploads/          # Directory where uploaded images are stored
‚îî‚îÄ‚îÄ views/                # (Currently unused)
```

---

## File-by-File Explanation

### `index.js` - The Server

This is the heart of the application.

- **`require(...)`**: Imports all necessary modules:
    - `express`: The web server framework.
    - `mongoose`: To connect to and interact with the MongoDB database.
    - `dotenv`: To load secrets from the `.env` file (like the `MONGO_URI`).
    - `./config/db.js`: The custom module for database connection logic.
    - `./routes/students.route.js`: The router containing all student-related API endpoints.

- **`connectDB()`**: Executes the function from `db.js` to establish the database connection when the server starts.

- **`app.use(...)`**: Mounts middleware functions. Middleware are functions that have access to the request (`req`) and response (`res`) objects.
    - **`express.urlencoded({ extended: false })`**: Parses incoming request bodies with URL-encoded payloads. This is how you get data from a standard HTML form.
    - **`express.json()`**: Parses incoming request bodies with JSON payloads. This is common for APIs that communicate with JavaScript frontends.
    - **`app.use('/uploads', express.static('routes/uploads'))`**: This is a crucial addition. It makes the `routes/uploads` directory publicly accessible. Without this, you wouldn't be able to view the uploaded profile pictures from the browser. For example, a file named `123.jpg` can be accessed at `http://localhost:3000/uploads/123.jpg`.
    - **`app.use('/api/students', studentRoutes)`**: This mounts the router from `students.route.js`. It means that any route defined in that file (e.g., `/`) will be accessible under the `/api/students` prefix (e.g., `http://localhost:3000/api/students/`).

- **`app.listen(3000, ...)`**: Starts the server on port 3000.

### `config/db.js` - Database Connector

This file's sole purpose is to connect to MongoDB.

- **`mongoose.connect(process.env.MONGO_URI)`**: It reads the MongoDB connection string from the `.env` file and uses Mongoose to connect to the database. Using `process.env` keeps your secret credentials out of the source code.

### `models/students.model.js` - Data Schema

This file defines the structure of a "student" document in the database.

- **`new mongoose.Schema(...)`**: Defines the fields, their data types, and any constraints for a student.
    - `first_name`, `last_name`, `email`, `phone`, `gender`: These are all defined as `String` type.
    - `profile_pic`: This field of type `String` will store the *filename* of the uploaded image, not the image itself.

- **`mongoose.model('Student', ...)`**: Compiles the schema into a `Student` model, which provides an interface to create, read, update, and delete documents in the `students` collection in MongoDB.

### `routes/students.route.js` - API Endpoints & Image Upload Logic

This file is the most complex. It defines the API routes and contains the logic for handling image uploads using the `multer` library.

#### Image Upload Setup (`multer`)

This was the area with the original bug.

- **`multer.diskStorage(...)`**: Configures how and where `multer` saves uploaded files.
    - **`destination`**: Specifies the directory to save files.
        - **Original Bug**: It was `cb(null, './uploads')`. This was incorrect because the `uploads` directory is inside `routes`. The path is relative to the project root, not the current file.
        - **The Fix**: It was changed to `cb(null, './routes/uploads')` to point to the correct folder.
    - **`filename`**: Determines the name of the saved file.
        - **Original Bug**: The function signature was `(req, res, cb)` but it used a variable named `file`.
        - **The Fix**: The signature was corrected to `(req, file, cb)` to correctly access the uploaded file's details. A new, unique filename is generated using `Date.now()` to prevent files with the same name from overwriting each other.

- **`fileFilter`**: A function to control which files are accepted. In this case, it checks if the file's `mimetype` starts with `image/`, ensuring only images can be uploaded.

- **`upload = multer(...)`**: Creates the `multer` middleware with the defined `storage`, `fileFilter`, and a file size `limit` of 3MB.

#### API Routes (`router.get`, `router.post`, etc.)

- **`POST /`**: This route handles creating a new student.
    - **`upload.single('profile_pic')`**: This is the key middleware for the upload. It tells `multer` to expect a single file in a field named `profile_pic` from the request. `multer` processes the file, saves it, and adds a `file` object to the `req` object.
    - **`if (req.file)`**: After the student is created from the request body (`req.body`), this check sees if a file was uploaded. If so, it saves the generated `filename` to the `student.profile_pic` field before saving the student to the database.

- **The other routes (`GET`, `PUT`, `DELETE`)** are standard CRUD operations using Mongoose functions like `find()`, `findById()`, `findByIdAndUpdate()`, and `findByIdAndDelete()`.

---

## Summary of Fixes

1.  **Corrected Multer Parameters**: The function signatures for `destination` and `filename` in the `multer` configuration were fixed to use the `file` object correctly.
2.  **Corrected Upload Path**: The `destination` path was updated to point to the `routes/uploads` directory.
3.  **Enabled Static File Serving**: A middleware was added to `index.js` to make the `uploads` directory public, allowing images to be viewed in the browser.

This documentation should provide a clear guide to understanding, running, and further developing this project.



################################# jwt token authentication ########################################
---------------------------------------------------------------------------------------------------
Below is the complete, beginner-friendly + interview-level explanation of JWT Token Authentication ‚Äî including what it is, how it works, purpose, benefits, and key features.

‚úÖ What Is JWT Authentication?

JWT (JSON Web Token) is a compact, secure, digitally signed token used to verify a user‚Äôs identity between the client (browser/app) and the server.

Once a user logs in successfully, the server creates a token and sends it to the client.
The client then uses this token for all further requests to access protected APIs (like profile, dashboard, logout, etc.)

üß© JWT Token Structure (Very Important)

A JWT has 3 parts, separated by dots:

header.payload.signature

1Ô∏è‚É£ Header

Contains metadata like token type and algorithm.

Example:

{
  "alg": "HS256",
  "typ": "JWT"
}

2Ô∏è‚É£ Payload

Contains user data (claims) like:

id

email

role (admin/user)

expiration time

Example:

{
  "id": 12,
  "email": "azaz@example.com",
  "role": "admin"
}

3Ô∏è‚É£ Signature

Used to verify token integrity using a secret key:

HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    secret
)

üöÄ How JWT Authentication Works (Step-By-Step Process)

This is the main working flow you must understand.

1Ô∏è‚É£ User Logs In

User enters:

email + password


Server verifies these details in the database.

2Ô∏è‚É£ Server Creates JWT Token

If login is valid:

server creates a JWT

embeds user data (id, email, role)

signs it using a secret key (ex: process.env.JWT_SECRET)

Example:

const token = jwt.sign({ id: user.id, role: user.role }, JWT_SECRET, { expiresIn: "1d" });

3Ô∏è‚É£ Server Sends Token to the Client

Token is returned in:

JSON response OR

stored in cookie (optional)

Example response:

{
  "message": "Login Successful",
  "token": "eyJhbGciOiJIUzI1NiIsInR...etc"
}

4Ô∏è‚É£ Client Stores the Token

Client saves the JWT:

LocalStorage

SessionStorage

HttpOnly Secure Cookie (recommended)

5Ô∏è‚É£ Client Sends Token in Every Request

For protected routes:

GET /profile
Authorization: Bearer <token>

6Ô∏è‚É£ Server Verifies Token

Middleware checks:

is token present?

is token valid?

is token expired?

does signature match?

7Ô∏è‚É£ Access Granted

If valid ‚Üí request proceeds.

If not ‚Üí error:

401 Unauthorized

403 Forbidden

üéØ Purpose of JWT Token Authentication
‚úî No need to store session on server (stateless)

JWT eliminates server-side session storage.

‚úî Lightweight, fast, and scalable authentication

Used in modern microservices architecture.

‚úî Secure way to identify users & roles

Used for:

role-based access control (RBAC)

admin/user routing

multi-login control

‚úî API security

Used widely in:

Node.js APIs

Mobile apps

React/Angular frontend

External API services

‚≠ê Benefits of JWT Authentication
1Ô∏è‚É£ Stateless Authentication

Server does NOT store any session.
Improves performance and scalability.

2Ô∏è‚É£ More Secure Compared to Sessions

Tokens are digitally signed and tamper-proof.

3Ô∏è‚É£ Faster API Calls

No database lookup required for each request.

4Ô∏è‚É£ Easy to Use in Frontend + Mobile Apps

Works well with:

React.js

Vue.js

React Native

Flutter

5Ô∏è‚É£ Can Store Custom Payload Data

Example:

role = "admin"

permissions

device info

6Ô∏è‚É£ Works Across Domains

Useful for microservices and distributed systems.

7Ô∏è‚É£ Supports Expiration

You can set:

token expires in 1 hour, 1 day, 30 days...

8Ô∏è‚É£ No Need for Cookies (Optional)

You can use:

LocalStorage

SessionStorage

Cookies

üîê Important Features of JWT Authentication
‚≠ê1. Self-contained Token

Contains all user info required for authentication.

‚≠ê2. Signing & Verification

Signed using HS256 or RS256 algorithms.

‚≠ê3. Expiration Time (exp)

Tokens automatically expire.

‚≠ê4. Issuer & Audience Claims

You can set secure metadata like:

issuer (iss)

audience (aud)

‚≠ê5. Role / Permission-Based Access

JWT helps create:

admin-only routes

API rate limit

multi-login systems

‚≠ê6. Refresh Tokens

Used to generate new tokens without logging in again.

‚≠ê7. Compact (Small Size)

Can easily be shared via:

HTTP headers

cookies

URLs

üß† One-Liner Summary (Interview Answer)

JWT is a stateless authentication mechanism that uses digitally signed tokens to securely verify user identity between client and server. A JWT contains header, payload, and signature, and is used for scalable, secure, session-less authentication in modern web apps.



Best practices & security notes

Store secrets safely: JWT_ACCESS_SECRET & JWT_REFRESH_SECRET must be long random strings and kept in environment variables / secrets manager.

Use short-lived access tokens: e.g., 5‚Äì15 minutes for better security.

Use refresh tokens: stored as HttpOnly, Secure cookies (prevents XSS).

Server-side refresh token store: store refresh tokens in DB with fields (userId, tokenHash, expiry, revoked) so you can revoke or rotate. Store token hashes instead of plaintext tokens if possible.

Refresh token rotation: on refresh, revoke old refresh token and issue a new one to reduce replay risk. If a rotated token is used twice, detect compromise and revoke all sessions.

Revoke / blacklist: keep a blacklist or mark tokens revoked in DB (applies to refresh tokens; for access tokens you can either keep them short or maintain a revocation list if necessary).

Use HTTPS in production: set secure: true on cookies.

Limit cookie path: set cookie path to refresh endpoint to reduce accidental exposures.

Avoid storing tokens in LocalStorage for refresh tokens (vulnerable to XSS). Access token in memory (or secure storage) and refresh token in HttpOnly cookie is a good pattern.

Include minimal claims: avoid putting sensitive data in the JWT payload because it is base64 encoded and readable by anyone.

Use aud and iss claims for stronger validation in distributed systems.

Consider using asymmetric keys (RS256) for large scale / third-party verification: sign with private key and verify with public key.



Alternatives & when to use JWT

JWT is great for stateless auth in APIs, SPAs, mobile apps, and microservices.

Use server-side sessions (traditional session+cookie) if:

You need easy server-side logout for access tokens, or

Your tokens must be revocable immediately and you don‚Äôt want to maintain refresh tokens.

Use OAuth2 / OpenID Connect for third-party login / delegated auth flows.

TL;DR Summary

JWT = signed token (header.payload.signature).

Access token: short-lived, used in Authorization header for protected APIs.

Refresh token: long-lived, stored server-side & as HttpOnly cookie; used to obtain new access tokens.

Best practice: short access token expiry, server-side stored refresh tokens (DB), refresh token rotation, use HTTPS & HttpOnly cookies.